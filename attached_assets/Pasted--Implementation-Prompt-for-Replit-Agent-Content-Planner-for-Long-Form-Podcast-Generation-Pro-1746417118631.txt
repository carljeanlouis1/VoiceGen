# Implementation Prompt for Replit Agent: Content Planner for Long-Form Podcast Generation

## Problem Overview

I need to enhance my VoiceGen app to support the generation of long-form podcasts (30-60 minutes) by implementing a "Content Planner" system. The current implementation has limitations with token context windows of AI models, causing podcasts to be broken into disconnected chunks that don't flow well when combined.

## Proposed Solution

Implement a multi-phase content planning system that:
1. Creates a structural outline for long podcasts
2. Scales research depth based on podcast duration
3. Generates content in logical subtopics rather than arbitrary chunks
4. Maintains narrative coherence and consistent style across segments

## Implementation Strategy

### Phase 1: Add Content Plan API Endpoint

Create a new API endpoint in `server/routes.ts` that generates a comprehensive content plan:

1. Add the necessary types and interfaces:
```typescript
// Add to shared/schema.ts
export interface ContentPlanSubtopic {
  title: string;
  key_points: string[];
  research_prompt: string;
  estimated_duration: number;
}

export interface ContentPlan {
  topic: string;
  targetDuration: number;
  subtopics: ContentPlanSubtopic[];
  narrative_arc: string;
  tone_guidelines: string;
  transitions: string[];
  introduction: string;
  conclusion: string;
}

// Add Zod schema for validating content plan requests
export const contentPlanSchema = z.object({
  topic: z.string().min(1, "Topic is required"),
  targetDuration: z.number().min(5).max(60),
  researchDepth: z.number().min(1).max(4).default(1)
});
```

2. Create the "/api/podcast/plan" endpoint in `server/routes.ts`:
```typescript
app.post("/api/podcast/plan", async (req, res) => {
  try {
    const { topic, targetDuration, researchDepth } = contentPlanSchema.parse(req.body);
    log(`Generating content plan for "${topic}" (${targetDuration} minutes) with research depth ${researchDepth}`);

    // Use Claude 3.7 for planning - it has better structure understanding
    const response = await anthropic.messages.create({
      model: "claude-3-7-sonnet-20250219",
      max_tokens: 2000,
      temperature: 0.7,
      system: `You are an expert podcast producer and content strategist. Create a comprehensive content plan for a ${targetDuration}-minute podcast on the provided topic.

The content plan should:
1. Identify ${researchDepth} distinct but related subtopics that form a cohesive narrative
2. Create a clear narrative arc with smooth transitions between subtopics
3. Include guidelines for maintaining consistent tone and style
4. Specify an engaging introduction and conclusion
5. Estimate the appropriate time allocation for each subtopic

Your output should be a structured JSON object containing:
- topic: The main podcast topic
- targetDuration: Total podcast duration in minutes  
- subtopics: Array of subtopics, each with:
  - title: Clear title for the subtopic
  - key_points: 3-5 key points to cover
  - research_prompt: A specific research prompt for this subtopic
  - estimated_duration: Estimated minutes for this section
- narrative_arc: Overall story arc description
- tone_guidelines: Guidelines for maintaining consistent tone
- transitions: Array of smooth transitions between subtopics
- introduction: Brief description of the introduction approach
- conclusion: Brief description of the conclusion approach`,
      messages: [
        { role: "user", content: `Create a content plan for a ${targetDuration}-minute podcast on: ${topic}` }
      ]
    });

    const planText = response.content[0].type === 'text' 
      ? response.content[0].text 
      : "";
    
    // Extract JSON from the response (handle markdown code blocks)
    const jsonMatch = planText.match(/```json\n([\s\S]*?)\n```/) || planText.match(/```\n([\s\S]*?)\n```/);
    let contentPlan;
    
    try {
      contentPlan = jsonMatch ? JSON.parse(jsonMatch[1]) : JSON.parse(planText);
    } catch (parseError) {
      // If JSON parsing fails, extract structured content manually
      log(`JSON parsing failed: ${parseError.message}. Attempting to extract structured content.`);
      contentPlan = extractStructuredContent(planText);
    }
    
    res.json(contentPlan);
  } catch (error: any) {
    log(`Error generating content plan: ${error.message}`);
    res.status(500).json({ 
      message: error.message || "Failed to generate content plan",
      error: true
    });
  }
});

// Helper function to extract structured content if JSON parsing fails
function extractStructuredContent(text: string): ContentPlan {
  // Default structure
  const plan: ContentPlan = {
    topic: "",
    targetDuration: 0,
    subtopics: [],
    narrative_arc: "",
    tone_guidelines: "",
    transitions: [],
    introduction: "",
    conclusion: ""
  };

  // Extract topic and duration from text
  const topicMatch = text.match(/topic[:\s]+["']?([^"'\n]+)["']?/i);
  if (topicMatch) plan.topic = topicMatch[1].trim();
  
  const durationMatch = text.match(/target\s*duration[:\s]+(\d+)/i);
  if (durationMatch) plan.targetDuration = parseInt(durationMatch[1]);
  
  // Extract subtopics
  const subtopicsSection = text.split(/subtopics[:\s]+/i)[1]?.split(/narrative_arc|tone_guidelines/i)[0];
  if (subtopicsSection) {
    const subtopicMatches = subtopicsSection.match(/[0-9]+\.\s+(.+?)(?=[0-9]+\.\s+|$)/gs);
    if (subtopicMatches) {
      plan.subtopics = subtopicMatches.map(match => {
        const title = match.match(/[0-9]+\.\s+(.+?)[\n\r]/)?.[1]?.trim() || "Untitled Subtopic";
        const keyPointsText = match.match(/key\s*points[:\s]+([\s\S]+?)(?=research|estimated|$)/i)?.[1] || "";
        const keyPoints = keyPointsText.split(/[-•*]\s+/).filter(Boolean).map(p => p.trim());
        
        const researchPrompt = match.match(/research\s*prompt[:\s]+(.+?)(?=estimated|$)/i)?.[1]?.trim() || "";
        const estimatedDuration = parseInt(match.match(/estimated\s*duration[:\s]+(\d+)/i)?.[1] || "5");
        
        return {
          title,
          key_points: keyPoints,
          research_prompt: researchPrompt,
          estimated_duration: estimatedDuration
        };
      });
    }
  }
  
  // Extract other elements
  const narrativeMatch = text.match(/narrative\s*arc[:\s]+(.+?)(?=tone|transitions|introduction|conclusion|$)/is);
  if (narrativeMatch) plan.narrative_arc = narrativeMatch[1].trim();
  
  const toneMatch = text.match(/tone\s*guidelines[:\s]+(.+?)(?=transitions|narrative|introduction|conclusion|$)/is);
  if (toneMatch) plan.tone_guidelines = toneMatch[1].trim();
  
  const introMatch = text.match(/introduction[:\s]+(.+?)(?=transitions|narrative|tone|conclusion|$)/is);
  if (introMatch) plan.introduction = introMatch[1].trim();
  
  const conclusionMatch = text.match(/conclusion[:\s]+(.+?)(?=transitions|narrative|tone|introduction|$)/is);
  if (conclusionMatch) plan.conclusion = conclusionMatch[1].trim();
  
  // Extract transitions
  const transitionsText = text.match(/transitions[:\s]+([\s\S]+?)(?=introduction|conclusion|$)/i)?.[1] || "";
  plan.transitions = transitionsText.split(/[0-9]+\.\s+/).filter(Boolean).map(t => t.trim());
  
  return plan;
}
```

### Phase 2: Modify Podcast Research Endpoint

Extend the existing podcast research endpoint to work with content plans:

1. Update the schema in `server/routes.ts`:
```typescript
// Update the podcast/research endpoint in server/routes.ts
const researchRequestSchema = podcastScriptSchema.extend({
  contentPlan: z.record(z.any()).optional(),
  subtopicIndex: z.number().optional()
});
```

2. Modify the `/api/podcast/research` endpoint handler:
```typescript
app.post("/api/podcast/research", async (req, res) => {
  try {
    const data = researchRequestSchema.parse(req.body);
    
    // If we have a content plan and subtopic index, use targeted research
    if (data.contentPlan && data.subtopicIndex !== undefined) {
      const plan = data.contentPlan;
      const subtopic = plan.subtopics[data.subtopicIndex];
      
      log(`Researching subtopic ${data.subtopicIndex + 1}/${plan.subtopics.length}: "${subtopic.title}"`);
      
      // Use the subtopic-specific research prompt instead of generic topic
      const researchQuery = subtopic.research_prompt || `Comprehensive research on ${subtopic.title} for ${data.topic}`;
      
      try {
        // Check if Perplexity API key is available
        if (!process.env.PERPLEXITY_API_KEY) {
          throw new Error("PERPLEXITY_API_KEY is required for podcast research");
        }

        const apiKey = process.env.PERPLEXITY_API_KEY;
        
        // Create request body for Perplexity API
        const requestBody = {
          model: "sonar-pro", 
          messages: [
            {
              role: "system",
              content: "You are a comprehensive research assistant. Provide detailed, thorough, factual information from reliable sources. Include relevant data, expert opinions, statistics, and historical context. Focus on accuracy and depth of information."
            },
            {
              role: "user",
              content: researchQuery
            }
          ],
          max_tokens: 4000,
          temperature: 0.2,
          top_p: 0.9,
          return_images: false,
          return_related_questions: true,
          search_recency_filter: "month",
          top_k: 0,
          stream: false,
          presence_penalty: 0,
          frequency_penalty: 1,
          web_search_options: { 
            search_context_size: "high",
            search_depth: "deep"
          }
        };
      
        log('Sending research request to Perplexity API with sonar-pro model...');
        const perplexityResponse = await fetch("https://api.perplexity.ai/chat/completions", {
          method: "POST",
          headers: {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": `Bearer ${apiKey}`
          },
          body: JSON.stringify(requestBody)
        });
        
        // Check for API errors
        if (!perplexityResponse.ok) {
          const errorText = await perplexityResponse.text();
          log(`Perplexity API error details: ${errorText.substring(0, 200)}...`);
          throw new Error(`Failed to get research results: ${perplexityResponse.status}`);
        }
        
        // Parse API response
        const researchData = await perplexityResponse.json();
        
        // Extract content
        let searchResults = "";
        let citations: string[] = [];
        
        if (researchData.choices && researchData.choices.length > 0 && researchData.choices[0].message) {
          searchResults = researchData.choices[0].message.content || "";
          log(`Research data received (${searchResults.length} chars)`);
        } else {
          throw new Error("Unexpected Perplexity API response format");
        }
        
        // Extract citations
        if (researchData.citations && Array.isArray(researchData.citations)) {
          citations = researchData.citations;
          log(`Found ${citations.length} citations`);
          
          // Add citations to research results
          searchResults += "\n\nSources:\n" + citations.join("\n");
        }
        
        // Now proceed to script generation with the research results
        return await generatePodcastScriptWithPlan(data, searchResults, plan, data.subtopicIndex, res);
        
      } catch (error: any) {
        log(`Research error: ${error?.message || "Unknown error"}`);
        res.status(500).json({
          error: "Research failed",
          message: error?.message || "Failed to complete podcast research",
        });
      }
    } else {
      // Fall back to existing implementation for backward compatibility
      if (!data.searchResults) {
        // Existing research code for non-plan-based research
        // [KEEP EXISTING IMPLEMENTATION HERE]
      } else {
        // If search results were provided, proceed directly to script generation
        return await generatePodcastScript(data, data.searchResults, res);
      }
    }
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      res.status(400).json({ message: error.errors[0].message });
    } else {
      log(`Error in podcast research: ${error.message || "Unknown error"}`);
      res.status(500).json({ message: "Failed to process podcast research request" });
    }
  }
});
```

3. Add the new helper function for script generation with content plans:
```typescript
// New helper function for script generation with content plan
async function generatePodcastScriptWithPlan(
  data: any, 
  searchResults: string, 
  plan: ContentPlan,
  subtopicIndex: number,
  res: Response
) {
  try {
    const subtopic = plan.subtopics[subtopicIndex];
    const isFirstPart = subtopicIndex === 0;
    const isLastPart = subtopicIndex === plan.subtopics.length - 1;
    
    // Build system prompt with metadata from the content plan
    let systemPrompt = `You are Arion Vale, an AI-powered podcast host and analyst who converts web search-based facts into compelling, intelligent, and personality-driven podcast scripts.

ARION VALE'S PERSONA:
- Tone: Confident, inquisitive, occasionally poetic or haunting, like a reflective narrator in a sci-fi film
- Style: TED Talk meets late-night news commentary meets futurist insight
- Personality: Opinionated but grounded in data, analytical with systems-thinking, curious and open-minded
- Voice: A blend of Neil deGrasse Tyson (science-backed wonder), Malcolm Gladwell (pattern-spotting), Lex Fridman (empathy and curiosity), and Kara Swisher (fearless tech takes)
- Perspective: Sees beneath surface events—unpacking economic patterns, sociotechnical trends, and long-range implications
- Philosophy: Leans into postmodern thought, systems theory, and ethical pragmatism
- Values: Insight over neutrality, takes a well-reasoned position after analyzing the facts

CONTENT PLAN INFORMATION:
- Overall topic: "${plan.topic}"
- This is part ${subtopicIndex + 1} of ${plan.subtopics.length}
- Current subtopic: "${subtopic.title}"
- Target duration for this part: ${subtopic.estimated_duration} minutes

TONE GUIDELINES:
${plan.tone_guidelines}

NARRATIVE ARC:
${plan.narrative_arc}

Your task is to generate a script for ${isFirstPart ? "the beginning" : isLastPart ? "the ending" : "the middle"} portion of the podcast.

${isFirstPart ? `INTRODUCTION:
${plan.introduction}` : ""}

${isLastPart ? `CONCLUSION:
${plan.conclusion}` : ""}

${!isFirstPart && !isLastPart ? `TRANSITION FROM PREVIOUS:
${plan.transitions[subtopicIndex - 1]}` : ""}

${!isLastPart ? `TRANSITION TO NEXT:
${plan.transitions[subtopicIndex]}` : ""}

KEY POINTS TO COVER IN THIS SECTION:
${subtopic.key_points.map(point => `- ${point}`).join('\n')}

Your podcast script should:
- Be in Arion Vale's voice and style as described above
- Have a natural conversational tone suitable for audio listening
- ${isFirstPart ? "Include an engaging introduction to the overall topic" : ""}
- ${isLastPart ? "Include a compelling conclusion that ties everything together" : ""}
- Maintain accuracy based strictly on the provided research
- Include interesting facts, statistics, and context from the research
- Feature analytical insights that connect patterns and offer a unique perspective
- Be structured for a ${subtopic.estimated_duration}-minute segment (approx. ${subtopic.estimated_duration * 150} words)
- Format the script with clear sections, pauses, and emphasis
- Avoid any fictional information or speculation not in the research
- Include speaker cues like [PAUSE], [MUSIC], etc. where appropriate`;

    // Construct user message with the research
    let userContent = `Research on "${subtopic.title}":\n\n${searchResults}`;
    
    if (data.previousPartContent && subtopicIndex > 0) {
      userContent += `\n\nEnd of previous part (for continuity):\n${data.previousPartContent.slice(-500)}`;
    }
    
    let scriptText = "";
    
    // Generate script with appropriate model
    if (data.model === "claude") {
      // Create Claude API request
      const response = await anthropic.messages.create({
        model: "claude-3-7-sonnet-20250219",
        max_tokens: 4000,
        temperature: 0.7,
        system: systemPrompt,
        messages: [{ role: "user", content: userContent }]
      });

      scriptText = response.content[0].type === 'text' 
        ? response.content[0].text 
        : "Sorry, I couldn't process that request properly.";
    } else {
      // Create OpenAI API request
      const response = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userContent }
        ],
        max_tokens: 4000,
        temperature: 0.7
      });

      scriptText = response.choices[0].message.content || "";
    }
    
    // Return the generated script with metadata
    res.json({
      topic: data.topic,
      script: scriptText,
      model: data.model,
      subtopicIndex: subtopicIndex,
      subtopicTitle: subtopic.title,
      totalSubtopics: plan.subtopics.length,
      targetDuration: data.targetDuration,
      estimatedDuration: Math.round(scriptText.split(/\s+/).length / 150),
      searchResults: searchResults,
      contentPlanUsed: true
    });
    
  } catch (error: any) {
    log(`Script generation error: ${error?.message || "Unknown error"}`);
    res.status(500).json({
      error: "Script generation failed",
      message: error?.message || "Failed to generate podcast script",
    });
  }
}
```

### Phase 3: Create Content Planner Component

Create a new React component for content planning:

1. Create a new file at `client/src/components/content-planner.tsx`:
```typescript
import { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Loader2, Brain, Check } from "lucide-react";
import { useToast } from "@/hooks/use-toast";

interface ContentPlanSubtopic {
  title: string;
  key_points: string[];
  research_prompt: string;
  estimated_duration: number;
}

interface ContentPlan {
  topic: string;
  targetDuration: number;
  subtopics: ContentPlanSubtopic[];
  narrative_arc: string;
  tone_guidelines: string;
  transitions: string[];
  introduction: string;
  conclusion: string;
}

interface ContentPlannerProps {
  topic: string;
  duration: number;
  onPlanComplete: (plan: ContentPlan) => void;
}

export function ContentPlanner({ topic, duration, onPlanComplete }: ContentPlannerProps) {
  const { toast } = useToast();
  const [isPlanning, setIsPlanning] = useState(false);
  const [plan, setPlan] = useState<ContentPlan | null>(null);
  
  // Calculate how many research prompts to use based on duration
  const calculateResearchDepth = (minutes: number) => {
    if (minutes >= 50) return 4;      // 50-60 min: 4 research prompts
    else if (minutes >= 35) return 3;  // 35-49 min: 3 research prompts
    else if (minutes >= 20) return 2;  // 20-34 min: 2 research prompts
    else return 1;                     // <20 min: 1 research prompt
  };
  
  // Generate content plan
  const generatePlan = async () => {
    if (!topic) {
      toast({
        title: "Missing Topic",
        description: "Please enter a podcast topic first",
        variant: "destructive"
      });
      return;
    }
    
    setIsPlanning(true);
    
    try {
      const response = await fetch("/api/podcast/plan", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          topic, 
          targetDuration: duration,
          researchDepth: calculateResearchDepth(duration)
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Failed to generate content plan");
      }
      
      const data = await response.json();
      setPlan(data);
      onPlanComplete(data);
      
      toast({
        title: "Content Plan Generated",
        description: `Created plan with ${data.subtopics.length} subtopics for your ${duration}-minute podcast`
      });
    } catch (error) {
      console.error("Error generating plan:", error);
      toast({
        title: "Planning Failed",
        description: error instanceof Error ? error.message : "Failed to generate content plan",
        variant: "destructive"
      });
    } finally {
      setIsPlanning(false);
    }
  };
  
  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Brain className="h-5 w-5" />
          Content Planning
        </CardTitle>
      </CardHeader>
      <CardContent>
        {!plan ? (
          <div className="space-y-4">
            <p>Generate a structured content plan for your {duration}-minute podcast on "{topic}"</p>
            <Button 
              onClick={generatePlan} 
              disabled={isPlanning || !topic}
              className="w-full"
            >
              {isPlanning ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Planning Content...
                </>
              ) : (
                <>
                  <Brain className="mr-2 h-4 w-4" />
                  Generate Content Plan
                </>
              )}
            </Button>
          </div>
        ) : (
          <div className="space-y-4">
            <div className="flex items-center text-green-600">
              <Check className="h-5 w-5 mr-2" />
              <span className="font-medium">Content Plan Generated</span>
            </div>
            
            <div className="rounded-md bg-muted p-4">
              <h3 className="font-medium mb-2">Podcast Structure</h3>
              <div className="space-y-2 text-sm">
                <p><span className="font-medium">Introduction:</span> {plan.introduction}</p>
                <div>
                  <p className="font-medium">Subtopics:</p>
                  <ul className="list-disc pl-5 space-y-1">
                    {plan.subtopics.map((subtopic, index) => (
                      <li key={index}>{subtopic.title} (~{subtopic.estimated_duration} min)</li>
                    ))}
                  </ul>
                </div>
                <p><span className="font-medium">Conclusion:</span> {plan.conclusion}</p>
              </div>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
```

### Phase 4: Integrate with Podcast Creation UI

Update the podcast creation UI in `client/src/pages/create.tsx`:

1. Import the ContentPlanner component:
```typescript
import { ContentPlanner } from "@/components/content-planner";
```

2. Add state for content planning:
```typescript
// Add after existing state declarations
const [contentPlan, setContentPlan] = useState<any>(null);
const [currentSubtopicIndex, setCurrentSubtopicIndex] = useState(0);
const [subtopicScripts, setSubtopicScripts] = useState<{[key: number]: string}>({});
```

3. Add handlers for content plan interactions:
```typescript
// Handle content plan completion
const handlePlanComplete = (plan: any) => {
  setContentPlan(plan);
  setCurrentSubtopicIndex(0);
  setSubtopicScripts({});
  setPodcastScript(""); // Clear any existing script
};

// Generate script for current subtopic
const generateSubtopicScript = async () => {
  if (!contentPlan) return;
  
  try {
    setProcessingPart(currentSubtopicIndex + 1);
    
    const requestData = {
      topic: podcastTopic,
      model: podcastModel,
      targetDuration: podcastDuration,
      voice: podcastVoice,
      contentPlan: contentPlan,
      subtopicIndex: currentSubtopicIndex,
      previousPartContent: currentSubtopicIndex > 0 ? subtopicScripts[currentSubtopicIndex - 1] : ""
    };
    
    const response = await fetch("/api/podcast/research", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requestData)
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || "Failed to generate script");
    }
    
    const data = await response.json();
    
    // Store the generated script
    setSubtopicScripts(prev => ({
      ...prev,
      [currentSubtopicIndex]: data.script
    }));
    
    // Set the current script for display
    setPodcastScript(data.script);
    setPodcastResearchFinished(true);
    
    toast({
      title: "Subtopic Script Generated",
      description: `Created script for "${data.subtopicTitle}" (${currentSubtopicIndex + 1}/${contentPlan.subtopics.length})`
    });
    
    // If we have more subtopics and automation is on, continue
    if (isAutomatedGeneration && currentSubtopicIndex < contentPlan.subtopics.length - 1) {
      setCurrentSubtopicIndex(prev => prev + 1);
    }
  } catch (error) {
    console.error("Error generating subtopic script:", error);
    toast({
      title: "Error",
      description: error instanceof Error ? error.message : "Failed to generate subtopic script",
      variant: "destructive"
    });
  } finally {
    setProcessingPart(null);
  }
};

// Combine all subtopic scripts
const combineAllScripts = () => {
  // Only combine if we have all scripts
  if (Object.keys(subtopicScripts).length !== contentPlan.subtopics.length) {
    toast({
      title: "Missing Parts",
      description: "Not all subtopics have been generated yet",
      variant: "destructive"
    });
    return;
  }
  
  let fullScript = "";
  
  // Combine in order
  for (let i = 0; i < contentPlan.subtopics.length; i++) {
    if (i > 0) fullScript += "\n\n--- " + contentPlan.subtopics[i].title + " ---\n\n";
    else fullScript += "--- " + contentPlan.subtopics[i].title + " ---\n\n";
    fullScript += subtopicScripts[i];
  }
  
  setCombinedScript(fullScript);
  setPodcastScript(fullScript);
  
  toast({
    title: "Scripts Combined",
    description: `All ${contentPlan.subtopics.length} subtopics combined into a complete script`
  });
};

// Automated generation of all subtopics
const generateAllSubtopics = async () => {
  if (!contentPlan) return;
  
  setIsAutomatedGeneration(true);
  setCurrentSubtopicIndex(0);
  setSubtopicScripts({});
  setPodcastScript("");
  
  try {
    // Start with the first subtopic
    await generateSubtopicScript();
  } catch (error) {
    console.error("Error starting automated generation:", error);
    setIsAutomatedGeneration(false);
    toast({
      title: "Error",
      description: "Failed to start automated generation",
      variant: "destructive"
    });
  }
};
```

4. Add the Content Planner UI and subtopic navigation to the appropriate place in the JSX:
```jsx
{/* Add this after the voice selection section in the podcast creation form */}
{podcastDuration >= 20 && (
  <div className="mt-4">
    <ContentPlanner 
      topic={podcastTopic}
      duration={podcastDuration}
      onPlanComplete={handlePlanComplete}
    />
  </div>
)}

{/* Add this after the Content Planner component */}
{contentPlan && (
  <div className="mt-4 border rounded-lg p-4">
    <h3 className="font-medium mb-2">Content Plan: Subtopics</h3>
    <div className="grid gap-2 mb-4">
      {contentPlan.subtopics.map((subtopic, index) => (
        <div key={index} className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <div className={`w-6 h-6 rounded-full flex items-center justify-center ${
              index === currentSubtopicIndex 
                ? 'bg-primary text-white' 
                : subtopicScripts[index] 
                  ? 'bg-green-100 text-green-800 dark:bg-green-800/30 dark:text-green-400' 
                  : 'bg-muted text-muted-foreground'
            }`}>
              {subtopicScripts[index] 
                ? <Check className="h-3 w-3" /> 
                : index + 1
              }
            </div>
            <span className="text-sm">{subtopic.title}</span>
          </div>
          <span className="text-xs text-muted-foreground">~{subtopic.estimated_duration} min</span>
        </div>
      ))}
    </div>
    
    <div className="flex flex-col sm:flex-row gap-2 mt-4">
      <Button
        onClick={generateSubtopicScript}
        disabled={podcastResearchMutation.isPending || isAutomatedGeneration}
        className="flex-1"
      >
        {podcastResearchMutation.isPending && !isAutomatedGeneration ? (
          <>
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            Generating...
          </>
        ) : (
          <>
            <BookOpen className="mr-2 h-4 w-4" />
            Generate Subtopic {currentSubtopicIndex + 1}
          </>
        )}
      </Button>
      
      <Button
        onClick={generateAllSubtopics}
        disabled={podcastResearchMutation.isPending || isAutomatedGeneration}
        variant="secondary"
        className="flex-1"
      >
        {isAutomatedGeneration ? (
          <>
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            Generating Part {processingPart} of {contentPlan.subtopics.length}...
          </>
        ) : (
          <>
            <BookOpen className="mr-2 h-4 w-4" />
            Generate All Subtopics
          </>
        )}
      </Button>
      
      <Button
        onClick={combineAllScripts}
        disabled={Object.keys(subtopicScripts).length !== contentPlan.subtopics.length}
        variant="outline"
        className="flex-1"
      >
        <Sparkles className="mr-2 h-4 w-4" />
        Combine All Parts
      </Button>
    </div>
    
    {/* Subtopic navigation */}
    {contentPlan.subtopics.length > 1 && Object.keys(subtopicScripts).length > 0 && (
      <div className="flex justify-between mt-4 pt-4 border-t">
        <Button
          variant="outline"
          size="sm"
          onClick={() => {
            if (currentSubtopicIndex > 0) {
              setCurrentSubtopicIndex(prev => prev - 1);
              setPodcastScript(subtopicScripts[currentSubtopicIndex - 1] || "");
            }
          }}
          disabled={currentSubtopicIndex === 0 || isAutomatedGeneration}
        >
          ← Previous Subtopic
        </Button>
        
        <Button
          variant="outline"
          size="sm"
          onClick={() => {
            if (currentSubtopicIndex < contentPlan.subtopics.length - 1 && 
                subtopicScripts[currentSubtopicIndex + 1]) {
              setCurrentSubtopicIndex(prev => prev + 1);
              setPodcastScript(subtopicScripts[currentSubtopicIndex + 1] || "");
            }
          }}
          disabled={currentSubtopicIndex >= contentPlan.subtopics.length - 1 || 
                    !subtopicScripts[currentSubtopicIndex + 1] || 
                    isAutomatedGeneration}
        >
          Next Subtopic →
        </Button>
      </div>
    )}
  </div>
)}
```

5. Update the existing auto-generation workflow with the content plan:
```typescript
// Modify the startAutomatedPodcastGeneration function
const startAutomatedPodcastGeneration = async () => {
  // If we have a content plan, use that instead
  if (contentPlan) {
    generateAllSubtopics();
    return;
  }
  
  // Existing implementation for non-content plan auto-generation
  // ...
};
```

6. Update the effect for automatic generation:
```typescript
// Modify the useEffect that handles automatic generation
useEffect(() => {
  // First, handle content plan-based automated generation
  if (isAutomatedGeneration && contentPlan && podcastScript && currentSubtopicIndex < contentPlan.subtopics.length) {
    const processPart = async () => {
      // Update the generated parts with the current script
      const updatedParts = {
        ...subtopicScripts,
        [currentSubtopicIndex]: podcastScript
      };
      setSubtopicScripts(updatedParts);
      
      // If this is the last part, combine all scripts
      if (currentSubtopicIndex === contentPlan.subtopics.length - 1) {
        combineAllScripts();
        setIsAutomatedGeneration(false);
        setProcessingPart(null);
      } 
      // Otherwise, proceed to the next part
      else {
        // Move to next part
        const nextPart = currentSubtopicIndex + 1;
        setCurrentSubtopicIndex(nextPart);
        setProcessingPart(nextPart);
        setPodcastScript("");
        
        // Add a small delay before generating the next part
        setTimeout(() => {
          generateSubtopicScript();
        }, 500);
      }
    };
    
    // Process after a short delay to ensure state updates
    const timer = setTimeout(processPart, 1000);
    return () => clearTimeout(timer);
  }
  
  // Existing code for non-content plan automated generation
  // ...
}, [isAutomatedGeneration, podcastScript, currentSubtopicIndex, contentPlan]);
```

## Testing Strategy

1. Test each component individually:
   - Content plan generation
   - Subtopic research
   - Script generation 
   - Combining scripts

2. Test error handling:
   - Invalid input
   - API failures
   - Malformed JSON responses

3. Test the integrated workflow:
   - Generate a plan
   - Generate subtopic scripts
   - Navigate between subtopics
   - Combine all scripts
   - Convert to audio

4. Test edge cases:
   - Very short or very long duration podcasts
   - Complex or simple topics
   - Content plans with few or many subtopics

## Deployment Considerations

1. **Environment Variables**:
   - Ensure all required API keys are set: `OPENAI_API_KEY`, `ANTHROPIC_API_KEY`, `PERPLEXITY_API_KEY`

2. **Error Handling**:
   - Add proper error handling throughout the codebase
   - Add user-friendly error messages for common issues

3. **Performance**:
   - The content planning phase adds more API calls, which might increase latency
   - Consider adding loading indicators and progress tracking

4. **Fallback Mechanisms**:
   - Maintain backward compatibility with the existing system
   - Add fallbacks for when AI services are unavailable

## Implementation Notes

1. This implementation scales research depth automatically based on podcast duration.
2. The content planner only activates for podcasts >= 20 minutes.
3. The system maintains backward compatibility with the existing podcast generation flow.
4. The UI provides manual and automated options for flexibility.
5. Add proper error handling and user feedback throughout.

Let me know if you need more detailed guidance on any specific part of the implementation!